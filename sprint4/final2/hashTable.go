/*
Яндекс Практикум
Алгоритмы и структуры данных
58 когорта
Агальцев Роман

Спринт 4
Задача - B. Хеш-таблица

Отчеты:
- Ревью 1 - https://contest.yandex.ru/contest/24414/run-report/113449962/
427ms/48.09Mb

-- ПРИНЦИП РАБОТЫ --
Из описания задачи можно выделить следующие задачи:
1. Написать реализацию хеш-таблицы;
2. Хеш-таблица должна поддерживать методы:
- put - добавляет пару ключ-значение в хеш-таблицу;
- get - получает значение из хеш-таблицы по ключу;
- delete - удаляет значение из хеш-таблицы по ключу.

Требования к реализации:
1. Имеющиеся реализации хеш-таблицы в ЯП использовать нельзя;
2. Разрешать коллизии следует с помощью метода цепочек или с помощью открытой адресации;
3. Поддерживать рехеширование и масштабирование хеш-таблицы не требуется;
4. Ключи и значения, id сотрудников и их зарплата, целые числа;
5. Поддерживать произвольные хешируемые типы не требуется.

Исходя из этого выбрал такой вариант решения:
- Хеш-таблица (далее ХТ) реализуется на основании структуры и набора методов у неё;
- Для разрешения коллизий используется метод цепочек:
	* Пары ключ-значение хранятся в связном списке;
	* В таблице структуры ХТ хранятся указатели на головы связных списков.

Теперь подробнее.

ХТ - это структура HashTable с двумя свойстами - емкость (целое число) и таблица (слайс указателей на структуры node).
Структура node используется для реализации связного списка - в таблице ХТ хранятся указатели на головы связных списков.

Для обеих структур реализованы методы-конструкторы - NewHashTable и newNode, соответственно.
Конструкторы создают объекты с инициализацией их свойств и возвращают указатель на объект.

Кроме этого, для обработки команд используется вспомогательная структура сommand.
В структуре хранится имя команды, ключ и значение.

Для структуры HashTable реализован набор методов:
- put - по переданному ключу записывает в ХТ переданное значение;
- get - по переданному ключу ищет и возвращает значение (если найдено);
- delete - по переданному ключу ищет значение, возвращает его (если найдено) и удаляет его из ХТ;
- index - формирует хэш переданного ключа и на его основании возращает индекс таблицы ХТ;
- findNode - по переданному указателю на голову связного списка ищет в нем и возвращает элемент (если найден),
	в котором ключ совпадает с переданным ключом;
- deleteNode - по переданному указателю на голову связного списка ищет в нем и возвращает элемент (если найден),
	в которому ключ совпадает с переданным ключом, а также удаляет найденный элемент из списка.
	При удалении элемента из связного списка, у него может измениться голова. Поэтому также возвращает указатель на голову.

Для обработки команд, поступающих с ввода, используется структура command и две функции:
- readCommand - при помощи сканера считывает команду с ввода и складывает её в структуру;
- executeCommand - выполняет переданную команду-структуру применительно к переданной ХТ.

Последовательность следующая:
- Создаем структуру ХТ. У неё сразу устанавливается значение емкости таблицы и инициализируется сама таблица;
- Считываем с ввода команды по одной и сразу по одной их обрабатываем;
- Результат обработки каждой команды передаем в буферный писатель;
- После обработки всех команд передаем содержимое буферного писателя на стандартный вывод.

Можно упомянуть про некоторые интересные моменты в решении:
- Хеш ключа при определении индекса таблицы ХТ формируется при помощи пакета fnv - нашел этот вариант на просторах интернета:
	* FNV (англ. Fowler–Noll–Vo) — простая хеш-функция для общего применения, разработанная Гленом Фаулером, Лондоном Керт Нолом и Фогном Во.
	* Не является криптографической функцией. https://ru.wikipedia.org/wiki/FNV
- При добавлении значения в ХТ возможны три варианта:
	* Если в ячейке таблицы ХТ пусто, просто создается новый элемент связного списка с добавляемым значением, элемент становится головой списка;
	* Иначе, выполняется поиск ключа в связном списке. Если элемент по ключу найден, в нём обновляется значение по переданному значению;
	* Иначе, создается новый элемент связного списка с добавляемым значением, элемент становится головой списка.
- При удалении значения из ХТ необходимо также удалять и элемент связного списка:
	* Если удаляемое значение хранится в элементе списка, который является головой, то у списка меняется голова;
	* Если удаляемое значение хранится в элементе списка, который расположен где-то между головой и хвостом (включая),
		то надо подменить указатель на следующий элемент в предыдущем от удаляемого элементе;
	* После выполнения операции указатель на голову в ячейке списка обновляется.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Основная задача выполнена - в решении реализована хеш-таблица с требуемым набором методов.

Также в реализации учтены требования и ограничения:
- Написана собственная реализация ХТ, без использования объекта map ЯП Go;
- Коллизии разрешаются при помощи метода цепочек - для хранения пар ключ-значение используются связные списки;

Решение проходит тесты Контеста в отведенные время и память - вердикт ОК.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Временная сложность операций решения соответствует сложности операций с хеш-таблицей при разрешении коллизий методом цепочек.

Примем следующие обозначения:
N — количество элементов, добавленных в таблицу
M — количество ячеек в таблице (емкость)
α - коэффициент заполнения ХТ, α = N/M

В лучшем случае, когда искомое значение находится в голове связного списка, операции добавления, поиска и удаления будут выполняться за константное время:
- Вычисление хеша ключа - O(1)
- Вычисление номера ячейки таблицы ХТ - O(1)
- Операция с головой списка - O(1)

При возникновении коллизии, когда в связном списке ячейки более одного элемента, приходится обходить список для поиска элемента по ключу.
В худшем случае, когда вообще все значения попадут в одну ячейку таблицы ХТ, сложность операций будет O(N).

В среднем случае, вероятность попадания в ячейку таблицы ХТ равна 1/M.
А сложность операций будет O(1+N/M) или O(1+α)
​
-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Примем следующие обозначения:
N — количество элементов, добавленных в таблицу
M — количество ячеек в таблице (емкость)

Так как в таблице ХТ хранятся не сами данные, а указатели на данные (связные списки), в пустых ячейках хранится nil.
Предполагаю, что для хранения ХТ потребуется столько памяти, сколько необходимо для хранения всех элементов всех связных списков.
Получается, что это O(N).

*/

package main

import (
	"bufio"
	"errors"
	"hash/fnv"
	"os"
	"strconv"
	"strings"
)

var (
	hashTableCapacity = 1000001 // Размер хеш-таблицы для инициализации
	errValueIsAbsent = errors.New("value is absent") // Ошибка отсутствия значения
)

// сommand - структура команды
type сommand struct {
	name string // Имя команды
	key int // Ключ
	value int // Значение
}

// node - структура связного списка для разрешения коллизий методом цепочек
type node struct {
	key int // Ключ
	value int // Значение
	next *node // Указатель на следующий элемент
}

// newNode - конструктор элемента связного списка
func newNode(key, value int, next *node) *node {
	return &node{
		key: key, // Ключ
		value: value, // Значение
		next: next, // Указатель на следующий элемент
	}
}

// HashTable - структура хеш-таблицы
type HashTable struct {
	capacity int // Размер таблицы
	table []*node // Таблица - слайс указателей на головы связных списков
}

// index - формирует и возращает индекс таблицы по переданному ключу
func (ht *HashTable) index(key int) int {
	// Сначала формируем хеш ключа
	h := fnv.New32()
	h.Write([]byte(strconv.Itoa(key)))
	hash := int(h.Sum32())
	// Затем возвращаем остаток от деления хеша на размер таблицы
	return hash % ht.capacity
}

// findNode - метод хеш-таблицы, выполняющий поиск элемента связного списка
//	по переданным указателю на голову этого списка и ключу.
//	Возвращает указатель на найденный элемент или nil
func (ht *HashTable) findNode(n *node, key int) *node {
	// Обходим связный список, пока не дошли до конца или не нашли нужный элемент
	for n != nil {
		// Если нашли элемент списка с переданным ключом
		if n.key == key {
			// Возвращаем этот элемент
			return n
		}
		// Переходим к следующему элементу
		n = n.next
	}
	// Не нашли элемент связного списка по переданному ключу
	return nil
}

// deleteNode - метод хеш-таблицы, выполняющий удаление элемента связного списка
//	по переданным указателю на голову этого списка и ключу.
//	Возвращает два указателя - на удаленный элемент списка и на голову списка (оба могут быть nil, голова может поменяться)
func (ht *HashTable) deleteNode(n *node, key int) (*node, *node) {
	// Проверяем, есть ли вообще список
	if n == nil {
		// Список пустой (отсутствует), возвращать нечего
		return nil, nil
	}
	// Проверяем, возможно нужный нам элемент - это голова
	if n.key == key {
		// Так и есть, возвращаем текущую и новую головы
		return n, n.next
	}
	// Искомый элемент не голова, надо искать и подменять указатели
	// Предыдущий элемент
	var prev *node
	// Сохраняем голову для возврата и текущий элемент списка
	head, curr := n, n
	// Обходим связный список, пока не дошли до конца или не нашли нужный элемент
	for curr != nil {
		// // Если нашли элемент списка с переданным ключом
		if curr.key == key {
			// Подменяем указатели
			prev.next = curr.next
			// И возвращаем текущий элемент и голову списка
			return curr, head
		}
		// Переходим дальше по связному списку
		prev = curr
		curr = curr.next
	}
	// Нужный элемент списка не нашли, но голову надо вернуть в любом случае
	return nil, head
}

// put - метод хеш-таблицы, выполняющий добавление переданного значения по переданному ключу
func (ht *HashTable) put(key, value int) {
	// По переданному ключу получаем индекс таблицы
	i := ht.index(key)
	// Берем из таблицы по индексу ссылку на голову связного списка
	node := ht.table[i]
	// Проверяем, что получили
	if node == nil {
		// Если получили nil, эта ячейка вообще пустая, связного списка нет
		// Создаем элемент списка и указатель на него записываем в таблицу
		ht.table[i] = newNode(key, value, nil) // Создаваемый элемент ссылается в никуда
	} else if nodeByKey := ht.findNode(node, key); nodeByKey != nil {
		// Если по переданному ключу нашли элемент в списке, обновляем значение - так по условию задачи
		node.value = value
	} else {
		// Иначе добавляем новый элемент в голову списка
		ht.table[i] = newNode(key, value, node) // Создаваемый элемент ссылается на текущую голову
	}
}

// get - метод хеш-таблицы, выполняющий поиск значения по переданному ключу
//	Возвращает значение и nil, если значение по ключу найдено
//	Возвращает 0 и ошибку, если значение по ключу не найдено
func (ht *HashTable) get(key int) (int, error) {
	// По переданному ключу получаем индекс таблицы
	i := ht.index(key)
	// По указателю на голову и ключу ищем элемент в списке
	node := ht.findNode(ht.table[i], key)
	// Проверяем, что нашли
	if node != nil {
		// Нашли элемент, возвращаем его значение и nil в качестве ошибки
		return node.value, nil
	}
	// Не нашли элемент, возвращаем 0 и ошибку
	return 0, errValueIsAbsent
}

// delete - метод хеш-таблицы, выполняющий удаление значения по переданному ключу
//	Возвращает значение и nil, если значение по ключу найдено
//	Возвращает 0 и ошибку, если значение по ключу не найдено
func (ht *HashTable) delete(key int) (int, error) {
	// По переданному ключу получаем индекс таблицы
	i := ht.index(key)
	// Берем из таблицы по индексу ссылку на голову связного списка
	node := ht.table[i]
	// Вызываем метод удаления элемента списка по ключу
	// Получаем указатели на найденный элемент и на голову связного списка (могла измениться)
	deletedNode, headNode := ht.deleteNode(node, key)
	// Указатель на голову записываем в таблицу - если удаляемый элемент является головой, nil
	ht.table[i] = headNode
	// Проверяем, был ли по ключу найден элемент
	if deletedNode != nil {
		// Элемент найден, возвращаем значение и nil
		return deletedNode.value, nil
	}
	// Элемент не найден, возвращаем 0 и ошибку
	return 0, errValueIsAbsent
	
}

// NewHashTable - конструкто хеш-таблицы
func NewHashTable() *HashTable {
	return &HashTable{
		capacity: hashTableCapacity, // Размер таблицы
		table: make([]*node, hashTableCapacity), // Сама таблица
	}
}

func main() {
	// Создаем сканер
	scanner := makeScanner()
	// Считываем с ввода количество команд
	commandsNumber := readInt(scanner)
	// Создаем новую хеш-таблицу
	hashTable := NewHashTable()
	// Переменная для результата выполнения команды
	result := ""
	// Создаем писатель для вывода
	writer := bufio.NewWriter(os.Stdout)
	// В цикле по считанному количеству читаем команды с ввода, выполняем, результат кладем в писатель
	for i := 0; i < commandsNumber; i++ {
		// readCommand - читаем команду с ввода сканером
		// executeCommand - выполняем команду, получаем результат
		result = executeCommand(hashTable, readCommand(scanner))
		// Выводим только непустые результаты
		if result != "" {
			writer.WriteString(result)
			writer.WriteString("\n")
		}
	}
	writer.Flush()
}

// makeScanner - создает новый сканер
func makeScanner() *bufio.Scanner {
	const maxCapacity = 10 * 1024 * 1024
	buf := make([]byte, maxCapacity)
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Buffer(buf, maxCapacity)
	return scanner
}

// readInt - читает целое число сканером с ввода
func readInt(scanner *bufio.Scanner) int {
	scanner.Scan()
	stringInt := scanner.Text()
	res, _ := strconv.Atoi(stringInt)
	return res
}

// readCommand - читает команду
func readCommand(scanner *bufio.Scanner) сommand {
	// Создаем новую структур команды
	command := сommand{}
	// Читаем строку команды
	scanner.Scan()
	// Разбиваем строку команды на имя, ключ и значение
	listCommand := strings.Split(scanner.Text(), " ")
	// Проверяем, что получили
	if len(listCommand) >= 2 {
		// Имя команды и ключ берем из первого и второго элементов
		command.name = listCommand[0]
		command.key, _ = strconv.Atoi(listCommand[1])
	}
	// Проверяем, есть ли третий элемент - в нем должно лежать значение
	if len(listCommand) == 3 {
		// Третий элемент есть, берем его
		command.value, _ = strconv.Atoi(listCommand[2])
	}
	// Возвращаем структур команды
	return command
}

func executeCommand(hashTable *HashTable, command сommand) string {
	// Служебные переменные
	var err error // Ошибка выполнения команды
	var value int // Результат выполнения команды
	var hasValue bool // Признак того, что выполнялась команда, возвращающая значение
	// По переданному имени команды вызываем метод хеш-таблицы
	switch command.name {
	case "put":
		// Добавление значения по ключу
		hashTable.put(command.key, command.value)
	case "get":
		// Получение значения по ключу
		value, err = hashTable.get(command.key)
		// Команда, возвращающая значение
		hasValue = true
	case "delete":
		// Получение значения по ключу с удалением
		value, err = hashTable.delete(command.key)
		// Команда, возвращающая значение
		hasValue = true
	}
	// Проверим, есть ли ошибка - все равно, какая команда выполнялась
	if err != nil {
		// Ошибка есть, возвращаем "None"
		return "None"
	}
	// Проверим, выполнялась ли команда, возвращающая значение
	if hasValue {
		// Выполнялась, вернем значение, преобразованное к строке
		return strconv.Itoa(value)
	}
	// Без ошибок выполнилась команда, которая не возвращает значение
	return ""
}