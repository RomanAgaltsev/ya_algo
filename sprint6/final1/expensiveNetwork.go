/*
Яндекс Практикум
Алгоритмы и структуры данных
58 когорта
Агальцев Роман

Спринт 6
Задача - A. Дорогая сеть

Отчеты:
- Ревью 1 - https://contest.yandex.ru/contest/25070/run-report/115778636/
- Ревью 2 - https://contest.yandex.ru/contest/25070/run-report/115817931/

-- ПРИНЦИП РАБОТЫ --
Принцип работы решения довольно простой:
1. Считываем с ввода данные и формируем граф;
2. Используя приоритетную очередь ребер, обходим граф, накапливая вес максимального остовного дерева (МОД) и отмечая посещенные вершины (отдельный слайс);
3. Так как приоритетная очередь выдает ребра с максимальным весом, то первый раз в вершину приходим по ребру с гарантированно максимальным весом;
4. Обход выполняется, пока в приоритетной очереди есть ребра;
5. Если по завершению обхода остались еще непосещенные вершины, значит, граф несвязный - выводится ошибка;
6. Если посетили все вершины, выводим вес МОД.

Наверное, можно сказать, что это алгоритм Прима.
Только он используется для построения минимального остовного дерева, а по задаче надо найти вес максимального - решается изменением оператора в функции-компараторе Less.

Для реализации графа используется структура Graph со следующими свойствами:
- Количество вершин - целое число;
- Количество посещенных вершин - целое число;
- Количество ребер - целое число;
- Список смежности - слайс слайсов целых чисел.

Для ребра используется структура Edge с двумя вершинами и весом ребра.

У структуры графа Graph реализованы методы:
- addEdge - добавляет ребро в граф (в список смежности графа);
- max - выполняет всю логику по обработке ребер дерева и вычислению веса МОД.

Приоритетная очередь реализована структурой EdgeQueue.
Полностью собственную реализацию не стал делать, воспользовался пакетом "container/heap".
В документации пакета есть пример реализации приоритетной очереди. Адаптировал его под задачу.
Ссылка на документацию и пример - https://pkg.go.dev/container/heap#example-package-PriorityQueue
Надо было только определить собственные методы структуры очереди - Len, Less, Swap, Push и Pop.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
По задаче необходимо найти и вывести вес максимального остовного дерева.
Так как используемая в решении приоритетная очередь всегда выдает ребро с максимальным весом из всех оставшихся в очереди,
В каждую вершину графа приходим по ребру с максимальным весом.
Если в дальнейшем очередь выдаст ребро в ту вершину, которая уже была посещена, срабатывает проверка посещения вершины.
Таким образом, накапливаются только максимальные веса ребер, а при повторных посещениях вершин веса не используются.

Кроме этого, решение обрабатывает ситуации:
1. Граф из одной вершины;
2. Граф без ребер;
3. Граф оказался несвязным.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Оценка для алгоритма Прима - O(E*log(V)).

Получается, общая оценка будет O(E*log(V))

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Оценка по памяти зависит от количества вершин и количества ребер графа.
Фактически, это список смежности (слайс слайсов), в котором для вершин хранятся списки ребер.

Это - O(V + E)

*/

package main

import (
    "bufio"
    "container/heap"
    "errors"
    "fmt"
    "os"
    "strconv"
    "strings"
)

// Ошибка для вывода, если максимального остовного дерева не существует
var errGraphIsDisconnected = errors.New("Oops! I did it again")

// Edge - структура ребра графа
type Edge struct {
    u, v, w int // Две вершины и вес
}

// Graph - структура графа
type Graph struct {
    verticesCount   int      // Количество вершин графа
    verticesVisited int      // Количество посещенных вершин
    edgesCount      int      // Количество ребер графа
    edges           [][]Edge // Список смежности графа - слайс слайсов
}

// addEdge - добавляет ребро в список смежности графа
func (g *Graph) addEdge(u, v, w int) {
    // Так как граф неориентированный, добавляем два ребра в список смежности
    // Добавляем ребро (u, v)
    g.edges[u] = append(g.edges[u], Edge{u, v, w})
    // Добавляем ребро (v, u)
    g.edges[v] = append(g.edges[v], Edge{v, u, w})
    // Увеличиваем количество ребер
    g.edgesCount++
}

// max - возвращает вес максимального остовного дерева (МОД) в графе:
// - если максимальное остовное дерево (МОД) существует, возвращается его вес и nil
// - если не существует, возвращается 0 и ошибка
func (g *Graph) max() (int, error) {
    // Для графа из единственной вершины вес МОД равен 0, ошибки нет
    if g.verticesCount == 1 {
        return 0, nil
    }
    // Для графа без ребер вес МОД равен 0, ошибка есть
    if g.verticesCount > 1 && g.edgesCount == 0 {
        return 0, errGraphIsDisconnected
    }
    // Слайс для хранения посещенных вершин
    visited := make([]bool, g.verticesCount+1)
    // Создаем приоритетную очередь ребер (она же куча)
    eq := &EdgeQueue{}
    // Кладем в очередь фиктивное ребро (-1, 1) с весом 0
    heap.Push(eq, Edge{-1, 1, 0})
    // Переменная для веса МОД
    maxWeight := 0
    // Берем ребра из очереди, пока есть что брать и накапливаем вес МОД
    for eq.Len() > 0 {
        // Берем ребро - очередь приоритетная, поэтому берется ребро с максимальным весом
        e := heap.Pop(eq).(Edge)
        // Если уже посещали смежную вершину v, пропускаем
        if visited[e.v] {
            continue
        }
        // Если еще не посещали смежную вершину v, отмечаем её как посещенную
        visited[e.v] = true
        g.verticesVisited++
        // Накапливаем вес МОД
        maxWeight += e.w
        // Получаем смежные вершины и обрабатываем в цикле
        for _, edge := range g.edges[e.v] {
            // Проверяем, не посещали ли смежную вершину v ранее
            if !visited[edge.v] {
                // Не посещали, кладем ребро в приоритетную очередь
                heap.Push(eq, edge)
            }
        }
    }
    // Проверяем, все ли вершины графа посетили в ходе обработки
    if g.verticesVisited != g.verticesCount {
        // Посетили не все вершины, вернем 0 и ошибку
        return 0, errGraphIsDisconnected
    }
    // Посетили все вершины, возвращаем вес и nil
    return maxWeight, nil
}

// EdgeQueue - структура приоритетной очереди, фактически - слайс ребер графа
type EdgeQueue []Edge

// Len - возвращает длину приоритетной очереди
func (eq EdgeQueue) Len() int { return len(eq) }

// Less - компаратор веса ребер графа
// В оригинале используется оператор сравнения "<", но нам надо извлекать ребра с максимальным весом,
// поэтому используем ">". Больше вес - выше приоритет.
func (eq EdgeQueue) Less(i, j int) bool { return eq[i].w > eq[j].w }

// Swap - меняет местами элементы очереди
func (eq EdgeQueue) Swap(i, j int) { eq[i], eq[j] = eq[j], eq[i] }

// Push - добавляет ребро графа в приоритетную очередь
func (eq *EdgeQueue) Push(x any) {
    *eq = append(*eq, x.(Edge))
}

// Pop - извлекает ребро графа из приоритетной очереди
func (eq *EdgeQueue) Pop() any {
    old := *eq
    n := len(old)
    edge := old[n-1]
    *eq = old[0 : n-1]
    return edge
}

func main() {
    // Создаем новый сканер
    scanner := makeScanner()
    // Считываем количество вершин и ребер графа
    nm := readArray(scanner)
    n, m := nm[0], nm[1]
    // Создаем новый граф
    g := &Graph{
        verticesCount: n,                   // Количество вершин заполняем в графе как есть
        edges:         make([][]Edge, 2*m), // Список связности создаем на двойное количество ребер, т.к. граф неоритентированный - можем переходить по ребру в обе стороны
    }
    // Считываем и заполняем ребра графа
    for i := 0; i < m; i++ {
        // Читаем ребро
        uvw := readArray(scanner)
        // Добавляем ребро в граф
        g.addEdge(uvw[0], uvw[1], uvw[2])
    }
    // Получаем вес МОД, если есть и ошибку
    maxWeight, err := g.max()
    // Проверяем, есть ли ошибка
    if err != nil {
        // Ошибка есть - выводим её
        fmt.Print(err)
        return
    }
    // Выводим вес МОД
    fmt.Print(maxWeight)
}

func makeScanner() *bufio.Scanner {
    const maxCapacity = 3 * 1024 * 1024
    buf := make([]byte, maxCapacity)
    scanner := bufio.NewScanner(os.Stdin)
    scanner.Buffer(buf, maxCapacity)
    return scanner
}

func readArray(scanner *bufio.Scanner) []int {
    scanner.Scan()
    listString := strings.Split(scanner.Text(), " ")
    arr := make([]int, len(listString))
    for i := 0; i < len(listString); i++ {
        arr[i], _ = strconv.Atoi(listString[i])
    }
    return arr
}
