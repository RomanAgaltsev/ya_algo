/*
Яндекс Практикум
Алгоритмы и структуры данных
58 когорта
Агальцев Роман

Спринт 5
Задача - B. Удали узел

Отчеты:
- Ревью 1 - https://contest.yandex.ru/contest/24810/run-report/114468520/

-- ПРИНЦИП РАБОТЫ --
Задача заключается в следующем:
- По переданному узлу - корню бинарного дерева поиска (BST) - и ключу необходимо удалить узел этого дерева, значение которого совпадает с ключом.

Чтобы по ключу удалить узел из BST, необходимо выполнить следующие действия:
1. Найти узел дерева, значение которого совпадает с ключом;
2. Корректно удалить искомый узел, сохранив свойства BST.

Для корректного удаления искомого узла, надо учесть возможные ситуации:
- Искомый узел является листом дерева - просто удаляем его без каки-либо перестановок;
- Искомый узел является родителем с одним ребенком (неважно, левым или правым) - заменяем искомый узел на ребенка и удаляем искомый;
- Искомый узел является родителем с двумя детьми (левым и правым) - самый сложный случай, требущий нескольких действий:
	* Найти приеемника для искомого узла дерева - это крайний левый ребенок правого ребенка искомого узла;
	* Выполнить замену искомого узла - можно просто заменить значение искомого узла на значение узла-преемника;
	* Удалить узел-преемник из поддерева правого ребенка искомого узла.

Для решения задачи используется рекурсивная функция remove, которая выполняет описанные выше действия и возвращает корень BST.
Порядок её работы такой:
- Сначала проверяем переданный узел на nil. Если узел равен nil, его и возвращаем;
- Если ключ меньше значения текущего узла, спускаемся в левое поддерево;
- Если ключ больше значения текущего узла, спускаемся в правое поддерево;
- Если ключ равен значению текущего узла (нашли искомый узел BST), выполняем действия по удалению этого узла:
	* Если у искомого узла отсутствует левый ребенок, заменяем его на правого ребенка;
	* Если у искомого узла отсутствует правый ребенок, заменяем его на левого ребенка;
	* Если у искомого узла присутствют оба ребенка, ищем преемника в правом поддереве, заменяем значение искомого узла на значение узла-преемник и удаляем узел-преемник.

Для поиска узла-преемника используется вспомогательная рекурсивная функция successor, возвращающая крайний левый узел-потомок переданного узла

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Решение прошло все тесты в Контесте. Вердикт - ОК.

Значит, функция удаления узла дерева по ключу корректная.
Также, по условию задачи, запрещено создавать новые вершины дерева - в решении новые узлы не создаются.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
В постановке задачи обозначено, что сложность функции удаления узла дерева должна быть O(h), где h - высота дерева.

Посмотрим, какая сложность у решения задачи.

Поиск узла дерева по ключу:
- В лучшем случае - O(1) - искомый узел находится на вершине всего BST;
- В худшем случае - O(n), где n - количество узлов дерева. Искомый узел является листом BST, а все узлы дерева, от вершины до листа представляют собой одну цепочку (h = n);
- В среднем случае - O(h), где h - высота дерева. В среднем случае, сложность поиска узла зависит от высоты дерева.

С операцией удаления ситуация другая:
- Найдя искомый узел, необходимо найти его преемника - O(n) в худшем, O(h) в среднем случае;
- Выполнив замену значения, необходимо удалить узел-преемник - O(n) в худшем, O(h) в среднем случае.

В итоге, если берем средний случай и отбрасываем константы, получаем сложность решения O(h).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Решение потребляет O(1) дополнительной памяти для переменных - на каждом шаге рекурсии используются несколько переменных.
Также для хранения стека рекурсивных вызовов требуется O(h) дополнительной памяти.

*/

package main

// <template>
type Node struct {
	value int
	left  *Node
	right *Node
}
// <template>

// successor - возвращает крайний левый узел-потомок для переданного узла дерева
func successor(node *Node) *Node {
	// Пока есть левый узел-ребенок
	for node.left != nil {
		// Идем влево, пока идется
		node = node.left
	}
	// Возвращаем последний узел
	return node
}

// remove - удаляет узел дерева по переданному ключу и возвращает корень измененного дерева
func remove(node *Node, key int) *Node {
	// Проверяем, существует ли узел
	if node == nil {
		// Не существует, можно вернуть node или nil
		return node
	}
	// Сравниванием переданный ключ со значением узла
	if key < node.value {
		// Ключ меньше значения узла, идем вниз по дереву влево (в левого ребенка)
		node.left = remove(node.left, key)
	} else if key > node.value {
		// Ключ больше значения узла, идем вниз по дереву вправо (в правого ребенка)
		node.right = remove(node.right, key)
	} else {
		// Ключ равен значению узла - это искомый узел дерева для удаления
		// Проверяем наличие детей у искомого узла
		if node.left == nil {
			// Левый ребенок отсутствует - заменяем искомый узел на правого ребенка
			// Сохраняем правого ребенка
			right := node.right
			// Удаляем искомый узел
			node = nil
			// Возвращаем правого ребенка как корень измененного дерева
			return right
		} else if node.right == nil {
			// Правый ребенок отсутствует - заменяем искомый узел на левого ребенка
			// Сохраняем левого ребенка
			left := node.left
			// Удаляем искомый узел
			node = nil
			// Возвращаем левого ребенка как корень измененного дерева
			return left
		}
		// У искомого узла в наличии оба ребенка - заменяем искомый узел на крайнего левого ребенка правого ребенка
		// Получаем преемника - крайнего левого ребенка правого ребенка при помощи рекурсивной функции
		succ := successor(node.right)
		// Подменяем значение искомого узла на значение преемника
		// Это позволит не менять ссылку у родителя искомого узла
		node.value = succ.value
		// Удаляем из поддерева правого ребенка узел со значением преемника
		// Полученное поддерево подвешиваем справа к текущему узлу
		node.right = remove(node.right, succ.value)
	}
	// Возвращаем корень измененного дерева
	return node
}

func test() {
	node1 := Node{2, nil, nil}
	node2 := Node{3, &node1, nil}
	node3 := Node{1, nil, &node2}
	node4 := Node{6, nil, nil}
	node5 := Node{8, &node4, nil}
	node6 := Node{10, &node5, nil}
	node7 := Node{5, &node3, &node6}
	newHead := remove(&node7, 10)
	if newHead.value != 5 {
		panic("WA")
	}
	if newHead.right != &node5 {
		panic("WA")
	}
	if newHead.right.value != 8 {
		panic("WA")
	}
}

func main() {
	test()
}