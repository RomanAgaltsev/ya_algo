/*
Яндекс Практикум
Алгоритмы и структуры данных
58 когорта
Агальцев Роман

Спринт 8
Задача - B. Шпаргалка

Отчеты:
- Ревью 1 - https://contest.yandex.ru/contest/26133/run-report/116162498/

-- ПРИНЦИП РАБОТЫ --
Идея решения следующая:
1. Считывается проверяемая строка;
2. Считываются слова, на которые будет разбиваться проверяемая строка;
3. На основании считанных слов строится префиксное дерево;
4. С использованием префиксного дерева и динамики выполняется проверка возможности разбивки считанной строки на считанные слова;

Само префиксное дерево реализовано следующим образом:
- Для хранения узла дерева используется структура Node с мапой (map[byte]*Node) children для хранения переходов и признаком терминального узла isTerminal;
- Для добавления слов в дерево используется метод insert - принимает слово и добавляет его в дерево;
- Новый узел дерева создается функцией newNode;
- Формирование всего префиксного дерева на основании считанных слов выполняется при помощи функции getTrie.

Проверка возможности разбивки считанной строки на слова выполняется функцией isLineSplitable - принимает строку и указатель на корневой узел префиксного дерева.
Для проверки используется слайс для одномерной динамики.
Логика проверки такая:
1. Создается слайс динамики с типов элементов bool в размере длины строки + 1;
2. В элемент с индексом 0 записывается true - считаем, что строку их 0 символов разбить можно;
3. Проверяемая строка обходится в цикле посимвольно. Для каждой итерации устанавливаем текущий узел дерева равным корневому;
4. Для каждого символа строки выполняется несколько действий:
 - Проверяется для предыдущей позиции, можно ли разбить строку до неё - если нельзя, то дальше с текущим символом ничего не выполняется;
 - Выполняется обход проверяемой строки с позиции текущего символа и до конца строки;
 - Если текущий узел префискного дерева является терминальным, записывается true в слайс динамики для текущей позиции;
 - Если достигнут конец строки или для текущего символа в префиксном дереве нет переходов (из текущего узла дерева), обработку текущего символа прерывается;
 - Выполняется переход из текущего узла префиксного дерева в следующий.
5. В качестве результата проверки разбивки возвращается последний элемент слайса динамики.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Для каждого символа строки (позиции в слайсе динамики) проверяется возможность разбивки префикса строки по данный символ (включая) на слова.
Если, добравшись до последнего символа строки, получаем положительный ответ (true в последнем элементе динамики), значит, вся строка может быть разбита на слова.

Таким образом, решая подзадачи о разбивке префикса строки на слова, решаем задачу разбивки всей строки.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Примем, что:
- L - суммарная длина всех слов, разбивку на которые надо проверить;
- M - длина самого длинного слова;
- T - длина проверяемой строки.

Сложность формирования префиксного дерева составляет O(L).
Проверка возможности разбивки строки составляет O(T * M).

Получается, что общая временная сложность - O(L + T * M).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Примем, что:
- L - суммарная длина всех слов, разбивку на которые надо проверить;
- M - длина самого длинного слова;
- T - длина проверяемой строки.

Для хранения хранения префиксного дерева требуется O(L) по памяти.
Для хранения слайса динамики требуется O(T) по памяти.

Получается, решение требует O(L + T) дополнительной памяти.

*/

package main

import (
    "bufio"
    "fmt"
    "os"
    "strconv"
)

const (
    // Константы для ответов
    yes = "YES" // Ответ, когда строку разбить возможно
    no  = "NO"  // Ответ, когда строку разбить нельзя
)

// Node - структура узла префиксного дерева
type Node struct {
    children   map[byte]*Node // Мапа для хранения переходов
    isTerminal bool           // Признак терминального узла
}

// insert - добавляет переданное слово в префиксное дерево
func (n *Node) insert(word string) {
    // Начинаем с корневого узла
    node := n
    // Обходим переданное слово посимвольно
    for i := 0; i < len(word); i++ {
        // Пытаемся получить переходы для текущего символа
        next, ok := node.children[word[i]]
        // Проверяем, есть ли переходы для текущего символа в принципе
        if !ok {
            // Переходов нет, добавляем новый узел для текущего символа
            next = newNode()
            // Для текущего узла добавляем переход в следующий по текущему символу
            node.children[word[i]] = next
        }
        // Делаем следующий узел текущим - переходим в него
        node = next
    }
    // Слово закончилось, для последнего узла устанавливаем признак терминального
    node.isTerminal = true
}

// newNode - создает новый узел префиксного дерева и возвращает ссылку на него
func newNode() *Node {
    // Создаем новый узел
    node := &Node{
        children:   make(map[byte]*Node), // Инициируем мапу переходов
        isTerminal: false,                // Признак терминального узла по умолчанию = false
    }
    // Возвращаем узел
    return node
}

// getTrie - создает новое префиксное дерево и возвращает ссылку на его корневой узел
func getTrie(scanner *bufio.Scanner) *Node {
    // Считываем количество допустимых к использованию слов
    n := readInt(scanner)
    // Создаем новый узел - корень префиксного дерева
    root := newNode()
    // Считываем слова
    for i := 0; i < n; i++ {
        // Каждое считанное слово добавляем в префиксное дерево
        root.insert(readLine(scanner))
    }
    // Возвращаем ссылку на корневой узел
    return root
}

// isLineSplitable - проверяет, можно ли разбить переданную строку на слова из словаря префиксного дерева:
// - false - разбить строку нельзя
// - true - разить строку возможно
func isLineSplitable(line string, root *Node) bool {
    // Сохраняем длину строки в переменную
    lenLine := len(line)
    // Создаем слайс для динамики по длине строки+1
    dp := make([]bool, lenLine+1)
    // Считаем, что строку из нуля символов можно разбить
    dp[0] = true
    // Обходим строку посимвольно для заполнения слайса динамики
    for i := 0; i <= lenLine; i++ {
        // Для каждого символа поиск будем выполнять, начиная с корневого узла
        node := root
        // Проверяем, можно ли разбить строку для предыдущей позиции
        // i-ый символ строки соответствует (i-1)-ому значению динамики
        if dp[i] {
            // Значение динамики true - имеет смысл идти дальше
            // Обходим строку посимвольно с текущей позиции и до конца строки
            for j := i; j <= lenLine; j++ {
                // Проверяем, текущий узел префиксного дерева не терминальный ли
                if node.isTerminal {
                    // Текущий узел терминальный - символами строки мы прошли в дереве слово полностью
                    // Значит, до текущей позиции разбить можно, записываем true в слайс динамики
                    dp[j] = true
                }
                // Если дошли до конца строки или для текущего символа нет переходов в префиксном дереве
                if j == lenLine || node.children[line[j]] == nil {
                    // Прерываем вложенный цикл
                    break
                }
                // Переходим из узла текущего символа в следующий
                node = node.children[line[j]]
            }
        }
    }
    // Искомый ответ хранится в последнем элементе слайса динамики
    return dp[lenLine]
}

func main() {
    // Создаем новый сканер
    scanner := makeScanner()
    // Проверяем, можно ли разбить считанную строку
    if isLineSplitable(readLine(scanner), getTrie(scanner)) {
        // Строку разбить можно - выводим "YES"
        fmt.Print(yes)
        return
    }
    // Строку разить нельзя - выводим "NO"
    fmt.Print(no)
}

func makeScanner() *bufio.Scanner {
    const maxCapacity = 3 * 1024 * 1024
    buf := make([]byte, maxCapacity)
    scanner := bufio.NewScanner(os.Stdin)
    scanner.Buffer(buf, maxCapacity)
    return scanner
}

func readInt(scanner *bufio.Scanner) int {
    scanner.Scan()
    stringInt := scanner.Text()
    res, _ := strconv.Atoi(stringInt)
    return res
}

func readLine(scanner *bufio.Scanner) string {
    scanner.Scan()
    return scanner.Text()
}
