/*
Яндекс Практикум
Алгоритмы и структуры данных
58 когорта
Агальцев Роман

Спринт 2
Задача - A. Дек

Отчеты:
- Ревью 1 - https://contest.yandex.ru/contest/22781/run-report/111443350/

-- ПРИНЦИП РАБОТЫ --
В описании задачи присутствует несколько ограничений:
- Написать дек с использованием кольцевого буфера;
- Максимальный размер дека ограничен заданным числом;
- Реализовать методы добавления и удаления как в начало (голову), так и в конец (хвост) дека;
- Необходимо написать эффективную реализацию.

Исходя из ограничений, решил реализовать дек с использованием слайса,
двух указателей и двух переменных (текущий и максимальный размер дека).
Слайс, в основе которого лежит массив, позволит эффективно реализовать кольцевой буфер и операции с ним.
А два указателя позволят управлять операциями добавления и удаления в начало и конец дека.
Первый указатель - head (голова) - используется для добавления и удаления в/с начала дека.
Второй указатель - tail (хвост) - используется для добавления и удаления в/с конца дека.

При реализации дека с использованием кольцевого буфера, помимо прочего, надо учесть важные особенности:
1. Кольцевой буфер сам по себе.
Слайс (массив) будто бы становится бесконечными, а его индексы как-будто "закицливаются".
Например, если размер буфера равен 5, то можно представить, что его индексы будут расположены так:
...3 4] [0 1 2 3 4] [0 1 2 3 4] [0 1 2 3 4] [0 1 2 3...
То есть, пока количество элементов в буфере (деке) не достигло максимально возможного, добавляемые/удаляемые элементы
"путешествуют" внутри него по кругу.

Чтобы реализовать эту особенность кольцевого буфера, пришел к следующей формуле вычисления следующей позиции указателя:
(<Указатель> + <Шаг> + <Максимальный размер>) % <Максимальный размер>

2. Логика перемещения указателей
В обычной очереди (queue) также используются два указателя - head (голова) и tail (хвост).
Но элементы добавляются только в хвост, а удаляются только с головы.
Поэтому, для обоих указателей логика хождения определена и не меняется:
 - tail всегда смотрит на пустую ячейку, при добавлении элемента, сначала в эту ячейку добавляется элемент, после указатель сдвигается вправо;
 - head всегда смотрит на заполненную ячейку, при извлечении элемента, сначала извлекается элемент, после указатель сдвигается вправо.

При работе же с деком, значения могут добавляться как в хвост, так и в голову.
Поэтому, при перемещении указателей используется такая логика.
Head (голова):
- head всегда смотрит на заполненную ячейку (исключение - пустой дек).
	При добавлении в голову, сначала head перемещается на 1 шаг влево, затем значение записывается в буфер (дек) в ячейку, на которую указывает head;
	При удалении с головы, сначала значение извлекается из буфера из ячейки, на которую указыает head, затем head перемещается на 1 шаг вправо.
- tail всегда смотрит на пустую ячейку (исключение - полный дек).
	При добавлении в хвост, сначала значение записывается в буфер в ячейку, на которую указывает tail, затем tail перемещается на 1 шаг в право;
	При удалении с хвоста, сначала tail перемещается на 1 шаг влево, затем значение извлекается из буфера из ячейки, на которую указывает tail.

То есть, указатели как-будто зеркалят друг друга.

Предполагаю, что, так как дек - это двухсторонняя очередь, логику перемещения head и tail можно поменять местами и будет работать корректно.
Главное, чтобы указатели перемещались и значения записывались/удалялись зеркально, а не одинаково.

Еще один момент - извлекаемые из дека значения не обязательно очищать в слайсе (перезаписывать нулем).
Диапазоном индексов буфера определяется область слайса, с которой мы работаем в данный момент (что есть в деке).
Всё, что вне диапазона, нам неинтересно. Поэтому можно не тратиться на перезапись - значения будут перезаписаны новыми при добавлении.
Небольшая, но экономия.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Получившаяся структура реализует дек при помощи кольцевого буфера:
- В структуре присутствует буфер, который является кольцевым (пример с индексами ниже);
- Добавление/извлечение значений в/из структуру возможно как с головы, так и с хвоста - это дек.
- Максимальный размер дека ограничен заданным числом - при попытке добавить новое значение в дек получаем ошибку;
- Так как дек реализован с использованием кольцевого буфера, в основе которого лежит слайс (а в его основе массив), операции вставки и удаления выполняются за O(1), то есть - эффективны.
	Для записи значения в дек выполняется 1 шаг указателя и 1 запись в слайс.
	Для извлечения значения из дека выполняется 1 шаг указателя и 1 чтение из слайса.

На примере того же буфера с 5 элементами, проверим, как перемещаются указатели.
Перемещение указателя с позиции 0 на 1 шаг вправо:
	(0 + 1 + 5) % 5 = 1
Перемещение указателя с позиции 0 на 1 шаг влево:
	(0 - 1 + 5) % 5 = 4
Перемещение указателя с позиции 2 на 1 шаг вправо:
	(2 + 1 + 5) % 5 = 3
Перемещение указателя с позиции 2 на 1 шаг влево:
	(2 - 1 + 5) % 5 = 1
Перемещение указателя с позиции 4 на 1 шаг вправо:
	(4 + 1 + 5) % 5 = 0
Перемещение указателя с позиции 4 на 1 шаг влево:
	(4 - 1 + 5) % 5 = 3
Таким образом, заложенная в реализацию формула позволяет получить корректный следующий индекс для перемещаения указателя по кольцевому буферу.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Для оценки временной сложности, за n принимаем количество команд на входе.

При выполнении кода время потратится на:
1. Иницицализация дека
- Ииницализация слайса для хранения буфера - О(k), где k - размер буфера
- Инициализация элементов структуры для хранения указателей, текущего и максимального количества - O(1)
- Чтение всех команд со входа и их выполнение - O(n), где n - количество команд
- Выполнение одной команды - O(1)

Инициализация дека выполняется каждый раз.
Если получен максимальный размер буфера, слайс под него будет инициирован в любом случае.
Даже если не будет получено ни одной команды.

Можно предположить, что при обработке n команд с ввода, не на каждую операцию выполняется операция с деком:
- если получена команда на добавление в дек, а он полон, то операция с деком не выполняется;
- если получена команда на удаления из дека, а он пуст, то операция с деком не выполняется.

Для оценки O большое используются худшие оценки.
Поэтому считаем, что на каждую полученную команду выполняется операция с деком.

Если отбросить константы, то получится O(k+n).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Для оценки пространственной сложности, за n принимаем количество команд на входе и за k максимальное количество значений в деке (буфер).

Для выполнения задачи в памяти необходимо хранить:
- Дек
	Слайс (буфер) с количеством элементов, равным максимальному - O(k)
	Переменные-свойства дека - индекс головы, индекс хвоста, максимальный размер, текущий размер - O(1)
- Команда
	Слайс - разбитая строка с входа - в слайсе всегда максимум два элемента - O(1)
	Структура - строка для имени команды и целое число для параметра (который может отсутствовать) - O(1)
- Входные параметры задачи
	Количество команд и максимальный размер дека - два целых числа - O(1)
- Переменная добавляемого/удаляемого значения
	При операциях с деком используется переменная (value) для хранения добавляемого/извлекаемого значения - O(1).

Получается, что кроме буфера дека, по памяти везде O(1). А для буфера дека необходимо O(k) по памяти.

-- ОПТИМИЗАЦИИ --
При решении задачи сделал следующие оптимизации:
1. Буферизированный вывод
Сначала сделал простой вывод, через fmt.Println - https://contest.yandex.ru/contest/22781/run-report/111400345/
 - Время теста - 213-217 ms
 - Память - 18,43-18,45 mb
Потом сделал буферизированный вывод через bufio.Writer - https://contest.yandex.ru/contest/22781/run-report/111402837/
 - Время теста - 50-57 ms
 - Память - 17,55-18,40 mb

2. Хранение команд
Сначала команды считывались с ввода и складывались в слайс. Потом слайс обходился в цикле и команды выполнялись - https://contest.yandex.ru/contest/22781/run-report/111402837/
- Время теста - 50-57 ms
- Память - 17,55-18,40 mb
Потом отказался от слайса для хранения команд - можно их выполнять сразу после чтения, без промежуточного хранения - https://contest.yandex.ru/contest/22781/run-report/111443350/
- Время теста - 28-32 ms
- Память - 4,96-5,95 mb

*/

package main

import (
	"bufio"
	"errors"
	"os"
	"strconv"
	"strings"
)

// Переменные для хранения ошибок
// С точки зрения вывода, какая из ошибок случилась - дек пустой или полный  - разницы нет, всегда выводим "error"
// Но для лучшей читаемости кода и для тестов (чтобы проверить тип ошибки) завел переменные
var (
	// Дек пустой
	errDequeIsEmpty = errors.New("deque is empty")
	// Дек полный
	errDequeIsFull = errors.New("deque is full")
)

// Deque - структура дека
type Deque struct {
	deque []int // Буфер храним в слайсе интов
	head int // Указатель на голову дека
	tail int // Указатель на хвост дека
	max int // Максимальный размер дека
	size int // Текущий размер дека
}

// newDeque - конструктор дека
// Инициализируем новый дек с использованием переданного размера буфера
func newDeque(n int) *Deque {
	return &Deque{
		deque: make([]int, n), // Инициализируем буфер (слайс интов) размера n
		head: 0, // Указатель на голову смотрит на 0
		tail: 0, // Указатель на хвост смотри на 0
		max: n, // Максимальный размер дека = n
		size: 0, // Текущий размер нового дека = 0
	}
}

// isEmpty - проверяет, пустой ли дек
func (d *Deque) isEmpty() bool {
	// Дек пустой, если его размер = 0
	return d.size == 0
}
// isFull - проверяет, полный ли дек
func (d *Deque) isFull() bool {
	// Дек полный, если его размер = максимальному
	return d.size == d.max
}

// moveHead - передвигает указатель на голову на переданное количество шагов:
// - положительное значение шага - двигаем вправо
// - отрицательное значение шага - двигаем влево
func (d *Deque) moveHead(step int) {
	// Формула одинаковая и для положительного, и для отрицательного шага
	d.head = (d.head + step + d.max) % d.max
}

// moveTail - передвигает указатель на хвост на переданное количество шагов:
// - положительное значение шага - двигаем вправо
// - отрицательное значение шага - двигаем влево
func (d *Deque) moveTail(step int) {
	// Формула одинаковая и для положительного, и для отрицательного шага
	d.tail = (d.tail + step + d.max) % d.max
}

// pushBack - добавляет переданное значение в хвост дека
func (d *Deque) pushBack(value int) error {
	// Проверяем, не полный ли дек
	if d.isFull() {
		// Дек полный, добавлять некуда - возвращаем ошибку
		return errDequeIsFull
	}
	// Записываем переданное значение в хвост - он всегда смотрит на свободную ячейку, если дек не полный
	d.deque[d.tail] = value
	// Двигаем хвост на 1 шаг вправо
	d.moveTail(1)
	// Увеличиваем текущий размер дека
	d.size += 1
	// Возвращаем ничего
	return nil
}

// pushFront - добавляет переданное значение в голову дека
func (d *Deque) pushFront(value int) error {
	// Проверяем, не полный ли дек
	if d.isFull() {
		// Дек полный, добавлять некуда - возвращаем ошибку
		return errDequeIsFull
	}
	// Двигаем голову на 1 шаг влево - голова всегда смотрит на занятую ячейку, если дек не пустой
	d.moveHead(-1)
	// Записываем переданное значение в голову
	d.deque[d.head] = value
	// Увеличиваем текущий размер дека
	d.size += 1
	// Возвращаем ничего
	return nil
}

// popFront - возвращает значение с головы и удаляет его из дека
func (d *Deque) popFront() (int, error) {
	// Проверяем, не пустой ли дек
	if d.isEmpty() {
		// Дек пустой, возвращать нечего - возвращаем ошибку
		return 0, errDequeIsEmpty
	}
	// Берем значение с головы - голова всегда смотрит на занятую ячейку, если дек не пустой
	value := d.deque[d.head]
	// Двигаем голову на 1 шаг право
	d.moveHead(1)
	// Уменьшаем текущий размер дека
	d.size -= 1
	// Возвращаем значение
	return value, nil
}

// popBack - возвращает значение с хвоста и удаляет его из дека
func (d *Deque) popBack() (int, error) {
	// Проверяем, не пустой ли дек
	if d.isEmpty() {
		// Дек пустой, возвращать нечего - возвращаем ошибку
		return 0, errDequeIsEmpty
	}
	// Двигаем хвост на 1 шаг влево - он всегда смотрит на свободную ячейку, если дек не полный
	d.moveTail(-1)
	// Берем значение с хвоста
	value := d.deque[d.tail]
	// Уменьшаем текущий размер дека
	d.size -= 1
	// Возвращаем значение
	return value, nil
}

// Command - структура команды
type Command struct {
	name string // Имя команды
	parameter int // Параметр команды
}

func main() {
	// Создаем сканер для чтения ввода
	scanner := makeScanner()
	// Читаем количество команд и максимальный размер дека
	commandsNumber, dequeMax := readInt(scanner), readInt(scanner)
	// Создаем новый дек - он сразу инициализируется
	deque := newDeque(dequeMax)
	// Переменная для результата выполнения команды
	result := ""
	// Создаем писатель для вывода
	writer := bufio.NewWriter(os.Stdout)
	// В цикле по считанному ранее количеству читаем команды с ввода, выполняем, результат кладем в писатель
	for i := 0; i < commandsNumber; i++ {
		// readCommand - читаем команду с ввода сканером
		// executeCommand - выполняем команду, получаем результат
		result = executeCommand(deque, readCommand(scanner))
		// Выводим только непустые результаты
		if result != "" {
			writer.WriteString(result)
			writer.WriteString("\n")
		}
	}
	writer.Flush()
}

// makeScanner - создает новый сканер
func makeScanner() *bufio.Scanner {
	const maxCapacity = 10 * 1024 * 1024
	buf := make([]byte, maxCapacity)
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Buffer(buf, maxCapacity)
	return scanner
}

// readInt - читает целое число сканером с ввода
func readInt(scanner *bufio.Scanner) int {
	scanner.Scan()
	stringInt := scanner.Text()
	res, _ := strconv.Atoi(stringInt)
	return res
}

// readCommand - читает команду
func readCommand(scanner *bufio.Scanner) Command {
	// Создаем новую структур команды
	command := Command{}
	// Читаем строку команды
	scanner.Scan()
	// Разбиваем строку команды на имя и параметр
	listCommand := strings.Split(scanner.Text(), " ")
	// Проверяем, есть ли вообще что-то
	if len(listCommand) >= 1 {
		// Что-то есть, имя команды берем из первого элемента
		command.name = listCommand[0]
	}
	// Проверяем, есть ли второй элемент - в нем должен лежать параметр команды
	if len(listCommand) == 2 {
		// Второй элемент есть, берем его, конвертируя в целое число
		command.parameter, _ = strconv.Atoi(listCommand[1])
	}
	// Возвращаем структуру команды
	return command
}

// executeCommand - выполняет переданную команду с переданным же деком
func executeCommand(deque *Deque, command Command) string {
	// Проверяем имя команды
	if command.name == "push_back" {
		// Это добавление в хвост
		err := deque.pushBack(command.parameter)
		// Проверяем, есть ли ошибка добавления
		if err != nil {
			// Ошибка есть, возвращаем "error"
			return "error"
		}
	}
	// Проверяем имя команды
	if command.name == "push_front" {
		// Это добавление в голову
		err := deque.pushFront(command.parameter)
		// Проверяем, если ли ошибка добавления
		if err != nil {
			// Ошибка есть, возвращаем "error"
			return "error"
		}
	}
	// Проверяем имя команды
	if command.name == "pop_front" {
		// Это вывод с удалением с головы
		value, err := deque.popFront()
		// Проверяем, есть ли ошибка
		if err != nil {
			// Ошибка есть, возвращаем "error"
			return "error"
		} else {
			// Ошибки нет, возвращаем значение, конвертируя его в строку
			return strconv.Itoa(value)
		}
	}
	// Проверяем имя команды
	if command.name == "pop_back" {
		// Это вывод с удалением с хвоста
		value, err := deque.popBack()
		// Проверяем, есть ли ошибка
		if err != nil {
			// Ошибка есть, возвращаем "error"
			return "error"
		} else {
			// Ошибки нет, возвращаем значение, конвертируя его в строку
			return strconv.Itoa(value)
		}
	}
	// Все предыдущие return сидят в if-ах, компилятор требует добавить return тут
	return ""
}