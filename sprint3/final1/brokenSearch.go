/*
Яндекс Практикум
Алгоритмы и структуры данных
58 когорта
Агальцев Роман

Спринт 3
Задача - A. Поиск в сломанном массиве

Отчеты:
- Ревью 1 - https://contest.yandex.ru/contest/23815/run-report/112512062/

-- ПРИНЦИП РАБОТЫ --
Сначала попробовал решить "в лоб" простым перебором входного массива.
Задача решается, но временная сложность такого решения будет O(n). А по условиям задачи необходимо найти решение за O(log n).
Решение за O(log n), скорее всего, это бинарный поиск. Поэтому пошел думать в эту сторону.

Следующая идея решения была такая:
- Найти величину сдвига изначального массива относительно начала текущего массива (слайса);
- Взять стандартный бинарный поиск;
- Прокинуть в функцию бинарного поиска найденный сдвиг;
- Модифицировать функцию бинарного поиска с использованием сдвига;
- Найти искомое значение во входном массиве (слайсе) модифицированным бинарным поиском.
Хотя эта идея и сулила решение за O(log n), от этой идеи отказался:
- Поиск величины сдвига, почему-то, сделал простым перебором, а это сразу O(n).
	В худшем случае, когда точка сдвига где-то ближе к n-1, только поиск сдвига уже совпадает с первой идеей - перебор всего массива в цикле;
- Модификация функции стандартного бинарного поиска для использования сдвига у меня не задалась. Код получался сложными для понимания;
- Какие-то тесты проходили, какие-то нет.

Следующая идея решения была такая:
- Найти границы изначального массива (начало и конец);
- Найденные границы делят входящий массив (слайс) на две части;
- Определить в какой из частей находится искомое значение;
- Найти искомое значение в той части, между границами которой оно находится.

Далее реализовал именно эту идею:
- Поиск границ изначального массива выполняется при помощи бинарного поиска;
- В какой из частей массива находится искомый элемент определяется простым сравнением искомого элемента с границами части массива;
- Поиск искомого значения в подмассиве выполняется при помощи бинарного поиска.

Начал с поиска границ изначального массива при помощи бинарного поиска.
Стандартный бинарный поиск не давал нужных результатов, так как возвращал только одно значение.
Плюс к этому, была проблема с границами и с определением базового случая для остановки рекурсии.
Стало понятно, что стандартный бинарный поиск не подходит и надо его модифицировать под поиск границ.

В своих закладках по алгоритмам нашел видео, в котором при помощи левого бинарного поиска реализовывался поиск в массиве первого вхождения значения.
Ссылка на видео - https://www.youtube.com/watch?v=_u2yypDA6R0. Стало понятно, что это нужный подход.
Предложенное в видео решение модифицировал под свои нужды. Поиск границ заработал как надо.

Логика поиска границ изначального массива:
- Используем бинарный поиск - так же делим массив на две части;
- Сравниваем значение в середине со значением в начале входного массива (слайса);
- Если значение в середине больше значения в начале, значит границы справа - проваливаемся во вложенный бин поиск с середины до конца;
- Если значение в середине меньше значения в начале, значит границы слева - проваливаемся во вложенный бин поиск с начала до середины.
- Останавливаем рекурсию, когда добрались до двух стоящих рядом элементов - это и есть искомые границы.

Идея проста.
Так как изначальный массив был отсортирован по возрастанию, то его границы - это два стоящих рядом элемента, из которых левый больше правого.
Исключения:
- Границы изначального массива совпадают с границами входного массива;
- Входной массив состоит из одного элемента.
Эти исключения явно проверяю в коде.

Например, если возьмем массив [19, 21, 100, 101, 1, 4, 5, 7, 12], то:
- Границы изначального массива находятся на индексах 3 и 4 - конец и начало, соответственно;
- Получаем два подмассива - [19, 21, 100, 101] и [1, 4, 5, 7, 12];
- При искомом значении равным 5, легко можем определить, что оно находится во втором подмассиве и вызвать стандартный бинарный поиск по нему.

Дальше было просто:
- Взял стандартный бинарный поиск;
- В функции brokenSearch собрал оба бинарных поиска и добавил исключения.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Могу выделить следующие критерии корректности решения:
1. Решение возвращает искомое значение или -1, если значение отсутствует - так и есть, тесты на Контесте пройдены;
2. Решение отрабатывает в рамках ограничений по времени и памяти - так и есть, опять же, тесты на Контесте пройдены;
3. Решение должно отрабатывать за O(log n) - используется бинарный поиск, он работает за O(log n).

Подробнее по последнему пункту ниже.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Так как в качестве решения на Контесте принимается только реализация поиска, оценивается только реализация поиска.
Чтение входящего массива, его обработка до поиска и вывод результата не оценивается.

С одной стороны, в решении бинарный поиск выполняется два раза - при поиске границ и при поиске искомого значения.
Это O(log n + log n) или O(2 * log n). Но константы мы отметаем, поэтому считаем, что O(log n).

С другой стороны, первый бинарный поиск (поиск границ), в худшем случае, отрабатывает за O(log n) - поиск выполняется во всем массиве (слайсе).
А вот второй бинарный поиск (поиск значения) выполняется уже не во всем массиве (слайсе), а только в его части.
Предполагаю, что:
- В худшем случае это будет тоже O(log n) - подмассив совпадает или почти совпадает с входящим массивом;
- В среднем случае это будет O(log n/2) - границы изначального массива делят входящий массив пополам;
- В лучшем случае это будет близко к O(1) - подмассив получился из одного элемента и это искомый элемент.

В итоге, считаю, что решение все-таки работает за требуемые O(log n).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Так как в качестве решения на Контесте принимается только реализация поиска, оценивается только реализация поиска.
Чтение входящего массива, его обработка до поиска и вывод результата не оценивается.

В решении используется память для:
- Массив (слайс) - O(n);
- Стек рекурсивных вызовов бинарного поиска границ - O(log n);
- Стек рекурсивных вызовов бинарного поиска значения - O(log n);
- Несколько переменных в коде - O(1).

В итоге, имеем O(n + log n + log n).

-- БЕНЧМАРК --
Чтобы удостовериться в корректности своих предположений, реализовал бенчмарк своего решения.
Благо, что Go позволяет достаточно легко это сделать и имеет для этого встроенные инструменты.

В файле brokenSearch_test.go функция BenchmarkBrokenSearch реализует бенчмарк:
// Выполняем бенчмарк для слайсов размера 10, 100, 1000, 10000, 100000, 1000000 и 10000000
for _, size := range []int{10, 100, 1_000, 10_000, 100_000, 1_000_000, 10_000_000} {
		b.Run(fmt.Sprintf("Size%d", size), func(b *testing.B) {
			// Инициируем слайс нужного размера
			ints := make([]int, size)
			// Заполняем слайс случайными целыми числами, значения до 10_000
			for i := range ints {
				ints[i] = rand.Intn(10_000)
			}
			// Сортируем слайс
			slices.Sort(ints)
			// Имитируем поломку слайса
			// Сдвиг - случайное число
			shift := rand.Intn(size)
			// Ломаем массив по сдвигу
			ints = append(ints[shift:], ints[:shift]...)
			// Искомое значение, до 10_000
			needle := rand.Intn(10_000)
			b.SetBytes(2)
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				brokenSearch(ints, needle)
			}
		})
	}

Замечание.
В описании задачи написано, что в массиве только уникальные элементы.
В бенчмарке с этим не стал заморачиваться - берется случайное число до 10 000. То есть, возможно, числа повторяются.

Результаты получились такие:
goos: windows
goarch: amd64
pkg: main/final1
cpu: AMD Ryzen 5 3600 6-Core Processor
BenchmarkBrokenSearch/Size10-12                 68535006                14.84 ns/op      134.76 MB/s
BenchmarkBrokenSearch/Size100-12                53908330                29.76 ns/op       67.21 MB/s
BenchmarkBrokenSearch/Size1000-12               30240715                40.20 ns/op       49.75 MB/s
BenchmarkBrokenSearch/Size10000-12              24843486                51.63 ns/op       38.74 MB/s
BenchmarkBrokenSearch/Size100000-12             23145379                57.05 ns/op       35.05 MB/s
BenchmarkBrokenSearch/Size1000000-12            21182288                61.46 ns/op       32.54 MB/s
BenchmarkBrokenSearch/Size10000000-12           18587475                63.11 ns/op       31.69 MB/s
PASS
ok      main/final1     14.044s

Что можно сказать по результатам:
- Видно, что при увеличении размера массива (слайса), время выполнения одного поиска тоже увеличивается;
- Чем больше размер массива (слайса), тем меньше прирост времени выполнения одного поиска;
- На мой взгляд, кривая результатов похожа на график бинарного поиска, то есть O(log n) - например, тут есть картинка - https://habr.com/ru/articles/782608/ или тут - https://cdn2.hexlet.io/store/derivatives/original/8a7d11b475915fe8241067d2a9c32540.png.
- Таким образом предположение, что решение работает за O(log n), похоже на правду )))

Когда гонял бенчмарк, его результаты немного гуляли туда-сюда.
Думаю, некоторая погрешность присутствует. Но для оценки достаточно.
*/

package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
	"strconv"
)

// getBoundaries - выполняет поиск границ изначального массива при помощи бинарного поиска
func getBoundaries(arr []int, begin, end int) (int, int) {
	// Проверяем, не дошли ли до двух стоящих рядом элементов
	if begin + 1 == end {
		// Дошли, останавливаем рекурсию и возвращаем результаты
		return end, begin
	}
	// Не дошли, идем дальше
	// Берем середину массива (слайса)
	middle := begin + (end - begin) / 2
	// Сравниваем значение в середине и значение в начале
	if arr[middle] > arr[begin] {
		// Значение в середине больше значения в начале
		// Значит, границы справа - проваливаемся во вложенный поиск с середины до конца
		return getBoundaries(arr, middle, end)
	} else {
		// Иначе - проваливаемся во вложенный поиск с начала до середины
		return getBoundaries(arr, begin, middle)
	}
}

// binarySearch - выполняет стандартный бинарный поиск
func binarySearch(arr []int, x, left, right int) int {
	if right <= left {
		return -1
	}
	mid := (left + right) / 2
	if arr[mid] == x {
		return mid
	} else if x < arr[mid] {
		return binarySearch(arr, x, left, mid)
	} else {
		return binarySearch(arr, x, mid+1, right)
	}
}

// brokenSearch - выполняет поиск искомого значения в сломанном массиве
func brokenSearch(arr []int, k int) int {
	// Переменные для хранения границ, в которых будем искать значение во входящем массиве (слайсе)
	var begin, end int
	// Проверим исключения - массив из одного элемента и входящий массив совпадает с изначальным
	if len(arr) == 1 || arr[0] < arr[len(arr)-1] {
		// Исключения подтвердились, берем границы входящего массива (слайса)
		begin, end = 0, len(arr)-1
	} else {
		// Исключения не подтвердились, границы изначального массива где-то между началом и концом входящего массива
		// Вызваем поиск границ изначального массива и используем его результаты далее
		begin, end = getBoundaries(arr, 0, len(arr)-1)
	}
	// Проверяем, в каком подмассиве находится наше искомое значение
	if k >= arr[0] && k <= arr[end] {
		// Искомое значение в левом подмассиве - от начала входящего массива до конца изначального массива
		return binarySearch(arr, k, 0, end+1)
	} else {
		// Искомое значение в правом подмассиве - от начала изначального массива до конца входящего массива
		return binarySearch(arr, k, begin, len(arr))
	}
}

func main() {
	scanner := makeScanner()
	readInt(scanner)
	k := readInt(scanner)
	arr := readArray(scanner)
	fmt.Print(brokenSearch(arr, k))
}

func makeScanner() *bufio.Scanner {
	const maxCapacity = 3 * 1024 * 1024
	buf := make([]byte, maxCapacity)
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Buffer(buf, maxCapacity)
	return scanner
}

func readArray(scanner *bufio.Scanner) []int {
	scanner.Scan()
	listString := strings.Split(scanner.Text(), " ")
	arr := make([]int, len(listString))
	for i := 0; i < len(listString); i++ {
		arr[i], _ = strconv.Atoi(listString[i])
	}
	return arr
}

func readInt(scanner *bufio.Scanner) int {
	scanner.Scan()
	stringInt := scanner.Text()
	res, _ := strconv.Atoi(stringInt)
	return res
}