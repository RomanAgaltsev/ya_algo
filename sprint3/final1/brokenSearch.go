/*
Яндекс Практикум
Алгоритмы и структуры данных
58 когорта
Агальцев Роман

Спринт 3
Задача - A. Поиск в сломанном массиве

Отчеты:
- Ревью 1 - https://contest.yandex.ru/contest/23815/run-report/112512062/
- Ревью 2 - https://contest.yandex.ru/contest/23815/run-report/112861020/

-- ПРИНЦИП РАБОТЫ --
Сначала попробовал решить "в лоб" простым перебором входного массива.
Задача решается, но временная сложность такого решения будет O(n). А по условиям задачи необходимо найти решение за O(log n).
Решение за O(log n), скорее всего, это бинарный поиск. Поэтому пошел думать в эту сторону.

Следующая идея решения была такая:
- Найти величину сдвига изначального массива относительно начала текущего массива (слайса);
- Взять стандартный бинарный поиск;
- Прокинуть в функцию бинарного поиска найденный сдвиг;
- Модифицировать функцию бинарного поиска с использованием сдвига;
- Найти искомое значение во входном массиве (слайсе) модифицированным бинарным поиском.
Хотя эта идея и сулила решение за O(log n), от этой идеи отказался:
- Поиск величины сдвига, почему-то, сделал простым перебором, а это сразу O(n).
	В худшем случае, когда точка сдвига где-то ближе к n-1, только поиск сдвига уже совпадает с первой идеей - перебор всего массива в цикле;
- Модификация функции стандартного бинарного поиска для использования сдвига у меня не задалась. Код получался сложными для понимания;
- Какие-то тесты проходили, какие-то нет.

Следующая идея решения была такая:
- Найти границы изначального массива (начало и конец);
- Найденные границы делят входящий массив (слайс) на две части;
- Определить в какой из частей находится искомое значение;
- Найти искомое значение в той части, между границами которой оно находится.

Далее реализовал именно эту идею:
- Поиск границ изначального массива выполняется при помощи бинарного поиска;
- В какой из частей массива находится искомый элемент определяется простым сравнением искомого элемента с границами части массива;
- Поиск искомого значения в подмассиве выполняется при помощи бинарного поиска.

Начал с поиска границ изначального массива при помощи бинарного поиска.
Стандартный бинарный поиск не давал нужных результатов, так как возвращал только одно значение.
Плюс к этому, была проблема с границами и с определением базового случая для остановки рекурсии.
Стало понятно, что стандартный бинарный поиск не подходит и надо его модифицировать под поиск границ.

В своих закладках по алгоритмам нашел видео, в котором при помощи левого бинарного поиска реализовывался поиск в массиве первого вхождения значения.
Ссылка на видео - https://www.youtube.com/watch?v=_u2yypDA6R0. Стало понятно, что это нужный подход.
Предложенное в видео решение модифицировал под свои нужды. Поиск границ заработал как надо.

Логика поиска границ изначального массива:
- Используем бинарный поиск - так же делим массив на две части;
- Сравниваем значение в середине со значением в начале входного массива (слайса);
- Если значение в середине больше значения в начале, значит границы справа - проваливаемся во вложенный бин поиск с середины до конца;
- Если значение в середине меньше значения в начале, значит границы слева - проваливаемся во вложенный бин поиск с начала до середины.
- Останавливаем рекурсию, когда добрались до двух стоящих рядом элементов - это и есть искомые границы.

Идея проста.
Так как изначальный массив был отсортирован по возрастанию, то его границы - это два стоящих рядом элемента, из которых левый больше правого.
Исключения:
- Границы изначального массива совпадают с границами входного массива;
- Входной массив состоит из одного элемента.
Эти исключения явно проверяю в коде.

Например, если возьмем массив [19, 21, 100, 101, 1, 4, 5, 7, 12], то:
- Границы изначального массива находятся на индексах 3 и 4 - конец и начало, соответственно;
- Получаем два подмассива - [19, 21, 100, 101] и [1, 4, 5, 7, 12];
- При искомом значении равным 5, легко можем определить, что оно находится во втором подмассиве и вызвать стандартный бинарный поиск по нему.

Дальше было просто:
- Взял стандартный бинарный поиск;
- В функции brokenSearch собрал оба бинарных поиска и добавил исключения.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Могу выделить следующие критерии корректности решения:
1. Решение возвращает искомое значение или -1, если значение отсутствует - так и есть, тесты на Контесте пройдены;
2. Решение отрабатывает в рамках ограничений по времени и памяти - так и есть, опять же, тесты на Контесте пройдены;
3. Решение должно отрабатывать за O(log n) - используется бинарный поиск, он работает за O(log n).

Подробнее по последнему пункту ниже.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Так как в качестве решения на Контесте принимается только реализация поиска, оценивается только реализация поиска.
Чтение входящего массива, его обработка до поиска и вывод результата не оценивается.

С одной стороны, в решении бинарный поиск выполняется два раза - при поиске границ и при поиске искомого значения.
Это O(log n + log n) или O(2 * log n). Но константы мы отметаем, поэтому считаем, что O(log n).

С другой стороны, первый бинарный поиск (поиск границ), в худшем случае, отрабатывает за O(log n) - поиск выполняется во всем массиве (слайсе).
А вот второй бинарный поиск (поиск значения) выполняется уже не во всем массиве (слайсе), а только в его части.
Предполагаю, что:
- В худшем случае это будет тоже O(log n) - подмассив совпадает или почти совпадает с входящим массивом;
- В среднем случае это будет O(log n/2) - границы изначального массива делят входящий массив пополам;
- В лучшем случае это будет близко к O(1) - подмассив получился из одного элемента и это искомый элемент.

В итоге, считаю, что решение все-таки работает за требуемые O(log n).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Так как в качестве решения на Контесте принимается только реализация поиска, оценивается только реализация поиска.
Чтение входящего массива, его обработка до поиска и вывод результата не оценивается.

В решении используется память для:
- Массив (слайс) - O(n);
- Стек рекурсивных вызовов бинарного поиска границ - O(log n);
- Стек рекурсивных вызовов бинарного поиска значения - O(log n);
- Несколько переменных в коде - O(1).

В итоге, имеем O(n + log n + log n).

-- БЕНЧМАРК --
Чтобы удостовериться в корректности своих предположений, реализовал бенчмарк своего решения.
Благо, что Go позволяет достаточно легко это сделать и имеет для этого встроенные инструменты.

В файле brokenSearch_test.go функция BenchmarkBrokenSearch реализует бенчмарк:
// Выполняем бенчмарк для слайсов размера 10, 100, 1000, 10000, 100000, 1000000 и 10000000
for _, size := range []int{10, 100, 1_000, 10_000, 100_000, 1_000_000, 10_000_000} {
		b.Run(fmt.Sprintf("Size%d", size), func(b *testing.B) {
			// Инициируем слайс нужного размера
			ints := make([]int, size)
			// Заполняем слайс случайными целыми числами, значения до 10_000
			for i := range ints {
				ints[i] = rand.Intn(10_000)
			}
			// Сортируем слайс
			slices.Sort(ints)
			// Имитируем поломку слайса
			// Сдвиг - случайное число
			shift := rand.Intn(size)
			// Ломаем массив по сдвигу
			ints = append(ints[shift:], ints[:shift]...)
			// Искомое значение, до 10_000
			needle := rand.Intn(10_000)
			b.SetBytes(2)
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				brokenSearch(ints, needle)
			}
		})
	}

Замечание.
В описании задачи написано, что в массиве только уникальные элементы.
В бенчмарке с этим не стал заморачиваться - берется случайное число до 10 000. То есть, возможно, числа повторяются.

Результаты получились такие:
goos: windows
goarch: amd64
pkg: main/final1
cpu: AMD Ryzen 5 3600 6-Core Processor
BenchmarkBrokenSearch/Size10-12                 68535006                14.84 ns/op      134.76 MB/s
BenchmarkBrokenSearch/Size100-12                53908330                29.76 ns/op       67.21 MB/s
BenchmarkBrokenSearch/Size1000-12               30240715                40.20 ns/op       49.75 MB/s
BenchmarkBrokenSearch/Size10000-12              24843486                51.63 ns/op       38.74 MB/s
BenchmarkBrokenSearch/Size100000-12             23145379                57.05 ns/op       35.05 MB/s
BenchmarkBrokenSearch/Size1000000-12            21182288                61.46 ns/op       32.54 MB/s
BenchmarkBrokenSearch/Size10000000-12           18587475                63.11 ns/op       31.69 MB/s
PASS
ok      main/final1     14.044s

goos: windows
goarch: amd64
pkg: main/final1
cpu: AMD Ryzen 5 3600 6-Core Processor
BenchmarkBrokenSearch/Size10-12                 158344038                7.651 ns/op     261.40 MB/s
BenchmarkBrokenSearch/Size100-12                99671552                12.59 ns/op      158.84 MB/s
BenchmarkBrokenSearch/Size1000-12               64158085                16.32 ns/op      122.55 MB/s
BenchmarkBrokenSearch/Size10000-12              54424236                21.52 ns/op       92.96 MB/s
BenchmarkBrokenSearch/Size100000-12             60885889                23.46 ns/op       85.24 MB/s
BenchmarkBrokenSearch/Size1000000-12            55570219                23.34 ns/op       85.68 MB/s
BenchmarkBrokenSearch/Size10000000-12           72088681                21.26 ns/op       94.06 MB/s
PASS
ok      main/final1     15.999s

Что можно сказать по результатам:
- Видно, что при увеличении размера массива (слайса), время выполнения одного поиска тоже увеличивается;
- Чем больше размер массива (слайса), тем меньше прирост времени выполнения одного поиска;
- На мой взгляд, кривая результатов похожа на график бинарного поиска, то есть O(log n) - например, тут есть картинка - https://habr.com/ru/articles/782608/ или тут - https://cdn2.hexlet.io/store/derivatives/original/8a7d11b475915fe8241067d2a9c32540.png.
- Таким образом предположение, что решение работает за O(log n), похоже на правду )))

Когда гонял бенчмарк, его результаты немного гуляли туда-сюда.
Думаю, некоторая погрешность присутствует. Но для оценки достаточно.
*/

package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
	"strconv"
)

// brokenSearch - сортирует сломанный массив итеративным бинарным поиском
func brokenSearch(arr []int, k int) int {
	// Указатели, с которыми будем работать - границы подмассива
	left, right := 0, len(arr)-1
	// Выполняем поиск до тех пор, пока указатели не сошлись
	for left <= right {
		// Вычисляем индекс среднего элемента
		mid := left + (right-left)/2
		// Проверим по среднему индексу, искомое ли это значение
		if arr[mid] == k {
			// Это искомое значение, его и возвращаем
			return mid
		}
		// Значение по среднему индексу не равно искомому - идем дальше
		// Проверим левый подмассив на границы изначального массива
		if arr[left] <= arr[mid] {
			// Левый подмассив отсортирован по возрастанию, значит границы изначального в правом подмассиве
			// Проверим наличие искомого значения в левом подмассиве
			if k < arr[mid] && k >= arr[left] {
				// Искомое значение в левом подмассиве
				right = mid - 1 // Двигаем правый указатель на средний-1
			} else {
				// Иначе, искомое значение в правом подмассиве
				left = mid + 1 // Двигаем левый указатель на средний+1
			}
		} else {
			// Правый подмассив отсортирован по возрастанию, значит границы изначального массива в левом подмассиве
			// Проверим наличие искомого значения в правом подмассиве
			if k <= arr[right] && k > arr[mid] {
				// Искомое значение в правом подмассиве
				left = mid + 1 // Двигаем левый указатель на средний+1
			} else {
				right = mid - 1 // Двигаем правый указатель на средний-1
			}
		}
	}
	// Искомое значение не нашли, возвращаем -1
	return -1
}

func main() {
	scanner := makeScanner()
	readInt(scanner)
	k := readInt(scanner)
	arr := readArray(scanner)
	fmt.Print(brokenSearch(arr, k))
}

func makeScanner() *bufio.Scanner {
	const maxCapacity = 3 * 1024 * 1024
	buf := make([]byte, maxCapacity)
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Buffer(buf, maxCapacity)
	return scanner
}

func readArray(scanner *bufio.Scanner) []int {
	scanner.Scan()
	listString := strings.Split(scanner.Text(), " ")
	arr := make([]int, len(listString))
	for i := 0; i < len(listString); i++ {
		arr[i], _ = strconv.Atoi(listString[i])
	}
	return arr
}

func readInt(scanner *bufio.Scanner) int {
	scanner.Scan()
	stringInt := scanner.Text()
	res, _ := strconv.Atoi(stringInt)
	return res
}