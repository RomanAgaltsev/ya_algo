/*
Яндекс Практикум
Алгоритмы и структуры данных
58 когорта
Агальцев Роман

Спринт 7
Задача - A. Расстояние по Левенштейну

Отчеты:
- Ревью 1 - https://contest.yandex.ru/contest/25597/run-report/115926734/

-- ПРИНЦИП РАБОТЫ --
По задаче необходимо рассчитать расстояние Левенштейна для двух считанных строк и вывести полученное значение - число.

Логика расчета расстояния Левенштейна достаточно подробно описана на Википедии:
https://en.wikipedia.org/wiki/Levenshtein_distance

Приводится три варианта реализации расчета:
1. Рекурсивное.
Простой, но не очень эффективный вариант, так как многократно повторяет одни и те же вычисления, а еще требует дополнительную память для стека вызовов.
2. Итеративное с использованием полной матрицы - алгоритм Вагнера — Фишера.
Вариант решения с использованием динамического программирование и полной матрицы динамики.
3. Итеративное с использованием двух строк матрицы.
Оптимизированный вариант 2. Для расчета используется не полная матрица, а только две строки - предыдущая и текущая.

Так как по задаче не требуется определение и вывод редакционного предписания (последовательность действий для получения из первой строки второй кратчайшим образом),
выбрал для реализации вариант 3 - https://en.wikipedia.org/wiki/Levenshtein_distance#Iterative_with_two_matrix_rows
- Для итеративной реализации, в отличие от рекурсивной, не требуется дополнительная память для хранения стека рекурсивных вызовов;
- Дополнительная память требуется для хранения не всей матрицы динамики, а только двух строк.

Принцип работы решения следующий:
1. Проверяем длины строк. Если первая строка короче второй, меняем строки местами;
2. Создаем два слайса prev и curr для хранения двух строк матрицы. Размер слайсов при инициализации задаем по длинной строке с увеличением на 1, чтобы считать с 1 индекса;
3. Выполняем обход строк и рассчитываем для каждой позиции три значения - стоимость удаления, стоимость вставки и стоимость замены;
4. Минимальное из рассчитанных значений записываем в слайс текущей строки матрицы для текущей позиции;
5. Так как в решении используется только две строки матрицы, то слайсы этих строк на каждой итерации внешнего цикла меняются местами.
Текущая строка становится предыдущей. На основании её данных на следующей итерации цикла будут рассчитаны значения новой текущей строки;
Предыдущая строка становится текущей. В ней остаются "старые" значения, но на следующей итерации они будут замены на корректные, вновь рассчитанные, значения.
Таким образом, на каждой итерации цикла накапливается рассчитанное расстояние Левенштейна;
6. После последней итерации внешнего цикла, нужный нам ответ лежит в предыдущей строке, в последнем элементе.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Для решения задачи используется готовый алгоритм Вагнера — Фишера с оптимизацией по использованию дополнительной памяти.
Расстояние Левенштейна для двух считанных строк рассчитывается и выводится.
Тесты на Контесте пройдены. Вердикт - ОК.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
В ходе расчета выполняется обход-обработка всех символов обеих строк.
Если длину одной строки принять за M, а другой за N, то для решения необходимо выполнить M * N операций.

Получается оценка O(M * N).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Дополнительная память для работы решения требуется для хранения двух слайсов строк матрицы.
Если длину короткой строки принять за M, а другой, длинной, за N, то создается два слайса размера N+1 - это O(2 * (N+1)).

Если отбросить константы, получаем оценку по памяти - O(N).

*/

package main

import (
    "bufio"
    "fmt"
    "os"
)

// LevenshteinDistance - рассчитывает и возвращает расстояние Левентштейна по переданным строкам
func LevenshteinDistance(s, t string) int {
    // Проверяем, не короче ли первая строка второй
    if len(s) < len(t) {
        // Первая строка короче второй, меняем их местами
        s, t = t, s
    }
    // Длины строк сохраним в переменные, чтобы каждый раз не считать
    lenS, lenT := len(s), len(t)
    // Создаем два слайса для предыдущей и текущей строки динамики
    prev := make([]int, lenS+1)
    curr := make([]int, lenS+1)
    // Заполняем расстояние до пустой строки
    for i := 0; i <= lenS; i++ {
        // Чтобы получить пустую строку из строки длинной i, надо выполнить i операций удаления
        prev[i] = i
    }
    // Начинаем обход со второй строки
    for i := 1; i < lenT+1; i++ {
        // Чтобы получить строку длиной i из пустой, нужно произвести i операций вставки
        curr[0] = i + 1
        // Обход первой строки
        for j := 1; j < lenS+1; j++ {
            // Рассчитываем стоимости операций для текущих позиций
            // Стоимость удаления
            deletionCost := prev[j] + 1
            // Стоимость вставки
            insertionCost := curr[j-1] + 1
            // Стоимость замены - зависит от совпадения символов строк
            substitutionCost := 0
            if t[i-1] == s[j-1] {
                // Если символы строк равны, стоимость замены не увеличиваем, берем предыдущую
                substitutionCost = prev[j-1]
            } else {
                // Если не равны, то увеличиваем
                substitutionCost = prev[j-1] + 1
            }
            // Берем минимальное значение из рассчитанных стоимостей
            curr[j] = min(deletionCost, insertionCost, substitutionCost)
        }
        // Меняем местами предыдущую и текущую строки динамики
        // "Кривые" значения prev в curr обновятся новыми, рассчитанными на следующей итерации цикла
        prev, curr = curr, prev
    }
    // После последней итерации внешнего цикла, нужный нам ответ лежит в предыдущей строке
    return prev[lenS]
}

func main() {
    // Создаем новый сканер
    scanner := makeScanner()
    // Считываем строки для расчета расстояния между ними
    s, t := readLine(scanner), readLine(scanner)
    // Вызываем расчет и сразу выводим результат
    fmt.Print(LevenshteinDistance(s, t))
}

func makeScanner() *bufio.Scanner {
    const maxCapacity = 3 * 1024 * 1024
    buf := make([]byte, maxCapacity)
    scanner := bufio.NewScanner(os.Stdin)
    scanner.Buffer(buf, maxCapacity)
    return scanner
}

func readLine(scanner *bufio.Scanner) string {
    scanner.Scan()
    return scanner.Text()
}
